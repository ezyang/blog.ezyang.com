---
title: "Ratchet Versioning"
date: 2017-11-26 16:07:34
slug: 
draft: true
categories: [Miscellaneous]
---

# Summary

Given a version number N, increase N when you make an incompatible API change. As a client, declare which version number N you use. As an implementer, condition on N to know what behavior to apply.

Ratchet versioning is most appropriate when old clients must continue working even in the face of BC-breaking changes.

# Introduction

In the life of every released API, there comes a point in time when a problem can be resolved only through a BC-breaking change. In many cases, a choice must be made: should the problem be fixed or backwards compatibility maintained? In many popular long-lived systems, an infinite commitment to backwards compatibility means that missing stairs and flagrant security hazards are never addressed.

In some systems, it is not difficult to maintain both old and new versions of an API; the old API may be implementable in terms of the new API, or it may be possible to ship both the old and new versions of code. In such cases, there is a simple way to avoid breaking old clients while evolving the API: require clients to declare what version they target and provide a different API depending this version. No BC breakage, no semantic versioning, no problem.

This idea is very simple, and is fairly widely used in the REST community (for example, [Stripe](https://stripe.com/blog/api-versioning) recently wrote a blog post about how they have maintained infinite backwards compatibility while evolving their API, by pinning customers to the versions of their API which was current at the time they signed up.) [Don Box](https://github.com/donbox) and I recently needed to add [operator versioning](https://github.com/onnx/onnx/issues/119) to [ONNX](http://onnx.ai/) (you can think of ONNX as a purely functional programming language with a lot of rapidly evolving built-in functions), and after many design iterations we ended up converging on a very similar versioning scheme.

In this blog post, I want to share some insights on ratchet versioning:

1.  Conceptually, you should think of ratchet versioning as an implementation of an [evolving namespace on top of an immutable store of specifications](http://blog.ezyang.com/2016/12/thoughts-about-spec-ulation-rich-hickey/). Ratchet versioning is a *specific* mechanism for identifying these namespaces, which has some good properties

Why a monotonically increasing integer

In this blog post, our model is that we are versioning an API consisting solely of functions (e.g.,

Ratchet versioning is decoupled from release versioning.

Semantically, ratchet versioning defines, for each version, a mapping of names into an immutable store of specifications. This perspective can help us understand the semantics of various protocols for conditioning on versions.

For example, consider the following protocol:

1.  The version number MAY be kept at the same number if a new function is added (in a backwards-compatible way). The function MUST NOT be available unless the client target version is greater than or equal to the version a function was added.
2.  The version number MUST be increased if a backwards incompatible change is made to a function. The implementation of a function MUST provide the old behavior if the client target version is less than the BC-breaking version.
3.  If the client target version is greater than the greatest known version, the backend MUST raise an error.

We can reexpress this protocol :

1.  If a new function f is added in version V, add a new specification f-V, and map f to f-V in the mapping for version V (copying all preexisting mappings from V-1).
2.  If a new function f is changed in a BC-breaking way in version V, add a new specification f-V, and remap f to f-V in the mapping for version V (otherwise copying all preexisting mappings from V-1).
3.  Version V of a software contains mappings from version 1 to V. If a client targets an unknown mapping, this is an error.
4.  Each
5.  If <span class="title-ref">f</span> changes in a backwards incompatible way in version N, then this corresponds to adding a new specification <span class="title-ref">f-N</span>, and modifying

Now there is something interesting going on with implementations
