---
title: "Dead Edward Day"
date: 2010-11-03 09:00:02
slug: dead-edward-day
categories: [Programming]
comments:
    - id: 1390
      author: The 27th Comrade
      date: "2010-11-03 10:49:51"
      content: "It is for this reason that I think it is foolish to put the general all-encompassing stigma against re-inventing the wheel that prevails at present. And why should people be ashamed of doing a poor implementation of X, even if it be the 100,000th, intending to use it for serious purposes? It is the better of two bad states, the other being having people who regard x.insert() as a magic chant."
    - id: 1391
      author: Thomas
      date: "2010-11-03 13:39:23"
      content: |
        Should programmers be required to implement the compiler/interpreter/runtime or whatever else applies in their particular situation, the tools with which they write and edit code or the operating systems whose calls are hidden away behind layers upon layers of libraries? And what about the computer hardware and microcode, the firmware of the devices. Or do you really have to understand the physical effects behind semiconductors, hard disks, and so on to even dare push the power button on a modern computer?
        
        Like in math you don't have to prove everything yourself. And most of the time the proofs that are done in math textbooks or in math classes are done quite sloppily. Most of the time formal proof is really not formal at all. It's a matter of convenience, a matter of concentrating on the things that really help you build your particular tower of abstractions. Why should software engineers be held to higher standards than most mathematicians?
    - id: 1393
      author: Edward Z. Yang
      date: "2010-11-03 19:16:41"
      content: |
        Thomas: I know it’s a rhetorical question, but I’ll answer it anyway, “Yes!” Although, you do phrase it in a bit stronger way: it’s not really a good idea to force people to reinvent the wheel (poorly), and then force them to use it. But I want my programmers to have, at some point, implemented pieces of a compiler/interpreter/runtime, looked at their text editor in funny ways when they needed some repetitive task done, appreciated the scope of the problem tackled by layers and layers of libraries, seen how to build from transistors to logic gates to a simple processor. It seems like basic computer literacy to me.
        
        I’m curious to know where your assessment that most proofs in math textbooks or in math classes are done quite sloppily comes from.
    - id: 1416
      author: Ben S
      date: "2010-11-08 03:03:22"
      content: |
        What makes a good computer scientist is that sense of when he's spinning his wheels trying to implement an algorithm (especially chasing bugs and working around edge cases) and needs to go back and dig through the math to get a clean, complete solution.
        
        There is some talent involved, but a big part is actual experience. A formal degree is particularly valuable in this regard as you get many opportunities to try to intuit the right way to implement an algorithm, fail miserably, and then back up, do the math and have it work perfectly.
---

Should software engineers be required to implement the abstractions use before using them? (Much like how before you’re allowed to use a theorem in a math textbook, you have to prove it first.) A bit like reinventing the wheel for pedagogical purposes.

(I've been sick since Saturday, so it’s a Dead Edward Day. Hopefully I’ll clean up the DP Zoo post and present it with more annotations for this Friday.)
