---
title: "Theme and variations: RAII guarding thread-local state in C++"
date: 2018-11-11 18:53:12
slug: 
draft: true
categories: [Miscellaneous]
---

**Theme.** Suppose you want to write an RAII guard which sets a thread local variable on construction, and then resets it to its original value on destruction. A bare-bones implementation is pretty simple:

    thread_local int current_flag = 0;
    struct Guard {
      Guard(int flag) : original_flag_(current_flag) {
        current_flag = flag;
      }
      ~Guard() {
        current_flag = original_flag_;
      }
      int original_flag_;
    };

**Variation 1: Short-circuiting an expensive setter.** Suppose it's not a thread local variable you're twiddling; it's actually a getter and setter from some third-party library (e.g., `cudaSetDevice` and `cudaGetDevice`). The setter and getter might be slow. In this case, you might like to avoid making unnecessary calls to the setter and getter if they're not necessary:

    struct CUDAGuard {
      CUDAGuard(int device) {
        CUDA_CHECK(cudaGetDevice(&original_device_));
        if (device != original_device_) {
          CUDA_CHECK(cudaSetDevice(device));
        }
        current_device_ = device;
      }
      ~CUDAGuard() {
        if (current_device_ != original_device_) {
          cudaSetDevice(original_device_); // return code ignored!
        }
      }
      int original_device_;
      int current_device_;
    };

There are two optimizations in the code above: first, if the requested new device is the same as the current device, skip the `cudaSetDevice` call. Second, if on exit, the guard thinks that the current device is the same as the original device, skip the `cudaSetDevice` that would restore the original device.

The first optimization is always sound, but the second is not: suppose you have the following program:

    // Current device is 0
    { 
      CUDAGuard g(0);
      cudaSetDevice(1);
    }
    // What's the current device now?
